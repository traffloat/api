<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Overview"><meta name="keywords" content="rust, rustlang, rust-lang, self_cell"><title>self_cell - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../self_cell/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate self_cell</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.10.1</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all self_cell's items</p></a><div class="block items"><ul><li><a href="#macros">Macros</a></li></ul></div><div id="sidebar-vars" data-name="self_cell" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">self_cell</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/self_cell/lib.rs.html#1-659" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="overview" class="section-header"><a href="#overview">Overview</a></h2>
<p><code>self_cell</code> provides one macro-rules macro: <a href="macro.self_cell.html" title="self_cell"><code>self_cell</code></a>. With this macro
you can create self-referential structs that are safe-to-use in stable Rust,
without leaking the struct internal lifetime.</p>
<p>In a nutshell, the API looks <em>roughly</em> like this:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="comment">// User code:</span>

<span class="macro">self_cell!</span>(
    <span class="kw">struct</span> <span class="ident">NewStructName</span> {
        <span class="ident">owner</span>: <span class="ident">Owner</span>,

        <span class="attribute">#[<span class="ident">covariant</span>]</span>
        <span class="ident">dependent</span>: <span class="ident">Dependent</span>,
    }

    <span class="kw">impl</span> {<span class="ident">Debug</span>}
);

<span class="comment">// Generated by macro:</span>

<span class="kw">struct</span> <span class="ident">NewStructName</span>(...);

<span class="kw">impl</span> <span class="ident">NewStructName</span> {
    <span class="kw">fn</span> <span class="ident">new</span>(
        <span class="ident">owner</span>: <span class="ident">Owner</span>,
        <span class="ident">dependent_builder</span>: <span class="kw">impl</span> <span class="kw">for</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">FnOnce</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Owner</span>) -&gt; <span class="ident">Dependent</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>
    ) -&gt; <span class="ident">NewStructName</span> { ... }
    <span class="kw">fn</span> <span class="ident">borrow_owner</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Owner</span> { ... }
    <span class="kw">fn</span> <span class="ident">borrow_dependent</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Dependent</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { ... }
}

<span class="kw">impl</span> <span class="ident">Debug</span> <span class="kw">for</span> <span class="ident">NewStructName</span> { ... }</code></pre></div>
<p>Self-referential structs are currently not supported with safe vanilla Rust.
The only reasonable safe alternative is to have the user juggle 2 separate
data structures which is a mess. The library solution ouroboros is really
expensive to compile due to its use of procedural macros.</p>
<p>This alternative is <code>no_std</code>, uses no proc-macros, some self contained
unsafe and works on stable Rust, and is miri tested. With a total of less
than 300 lines of implementation code, which consists mostly of type and
trait implementations, this crate aims to be a good minimal solution to the
problem of self-referential structs.</p>
<p>It has undergone <a href="https://users.rust-lang.org/t/experimental-safe-to-use-proc-macro-free-self-referential-structs-in-stable-rust/52775">community code
review</a>
from experienced Rust users.</p>
<h4 id="fast-compile-times" class="section-header"><a href="#fast-compile-times">Fast compile times</a></h4><div class="example-wrap"><pre class="language-txt"><code>$ rm -rf target &amp;&amp; cargo +nightly build -Z timings

Compiling self_cell v0.7.0
Completed self_cell v0.7.0 in 0.2s</code></pre></div>
<p>Because it does <strong>not</strong> use proc-macros, and has 0 dependencies
compile-times are fast.</p>
<p>Measurements done on a slow laptop.</p>
<h4 id="a-motivating-use-case" class="section-header"><a href="#a-motivating-use-case">A motivating use case</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">self_cell::self_cell</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Ast</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="kw">pub</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">str</span><span class="op">&gt;</span>);

<span class="macro">self_cell!</span>(
    <span class="kw">struct</span> <span class="ident">AstCell</span> {
        <span class="ident">owner</span>: <span class="ident">String</span>,

        <span class="attribute">#[<span class="ident">covariant</span>]</span>
        <span class="ident">dependent</span>: <span class="ident">Ast</span>,
    }

    <span class="kw">impl</span> {<span class="ident">Debug</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>}
);

<span class="kw">fn</span> <span class="ident">build_ast_cell</span>(<span class="ident">code</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) -&gt; <span class="ident">AstCell</span> {
    <span class="comment">// Create owning String on stack.</span>
    <span class="kw">let</span> <span class="ident">pre_processed_code</span> <span class="op">=</span> <span class="ident">code</span>.<span class="ident">trim</span>().<span class="ident">to_string</span>();

    <span class="comment">// Move String into AstCell, then build Ast inplace.</span>
    <span class="ident">AstCell::new</span>(
       <span class="ident">pre_processed_code</span>,
       <span class="op">|</span><span class="ident">code</span><span class="op">|</span> <span class="ident">Ast</span>(<span class="ident">code</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">filter</span>(<span class="op">|</span><span class="ident">word</span><span class="op">|</span> <span class="ident">word</span>.<span class="ident">len</span>() <span class="op">&gt;</span> <span class="number">1</span>).<span class="ident">collect</span>())
    )
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">ast_cell</span> <span class="op">=</span> <span class="ident">build_ast_cell</span>(<span class="string">&quot;fox = cat + dog&quot;</span>);

    <span class="macro">println!</span>(<span class="string">&quot;ast_cell -&gt; {:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">ast_cell</span>);
    <span class="macro">println!</span>(<span class="string">&quot;ast_cell.borrow_owner() -&gt; {:?}&quot;</span>, <span class="ident">ast_cell</span>.<span class="ident">borrow_owner</span>());
    <span class="macro">println!</span>(<span class="string">&quot;ast_cell.borrow_dependent().0[1] -&gt; {:?}&quot;</span>, <span class="ident">ast_cell</span>.<span class="ident">borrow_dependent</span>().<span class="number">0</span>[<span class="number">1</span>]);
}</code></pre></div>
<div class="example-wrap"><pre class="language-txt"><code>$ cargo run

ast_cell -&gt; AstCell { owner: &quot;fox = cat + dog&quot;, dependent: Ast([&quot;fox&quot;, &quot;cat&quot;, &quot;dog&quot;]) }
ast_cell.borrow_owner() -&gt; &quot;fox = cat + dog&quot;
ast_cell.borrow_dependent().0[1] -&gt; &quot;cat&quot;</code></pre></div>
<p>There is no way in safe Rust to have an API like <code>build_ast_cell</code>, as soon
as <code>Ast</code> depends on stack variables like <code>pre_processed_code</code> you can’t
return the value out of the function anymore. You could move the
pre-processing into the caller but that gets ugly quickly because you can’t
encapsulate things anymore. Note this is a somewhat niche use case,
self-referential structs should only be used when there is no good
alternative.</p>
<p>Under the hood, it heap allocates a struct which it initializes first by
moving the owner value to it and then using the reference to this now
Pin/Immovable owner to construct the dependent inplace next to it. This
makes it safe to move the generated SelfCell but you have to pay for the
heap allocation.</p>
<p>See the documentation for <a href="macro.self_cell.html" title="self_cell"><code>self_cell</code></a> to dive further into the details.</p>
<p>Or take a look at the advanced examples:</p>
<ul>
<li>
<p><a href="https://github.com/Voultapher/self_cell/tree/main/examples/fallible_dependent_construction">Example how to handle dependent construction that can
fail</a></p>
</li>
<li>
<p><a href="https://github.com/Voultapher/self_cell/tree/main/examples/lazy_ast">How to build a lazy AST with
self_cell</a></p>
</li>
<li>
<p><a href="https://github.com/Voultapher/self_cell/tree/main/examples/owner_with_lifetime">How to use an owner type with
lifetime</a></p>
</li>
</ul>
<h4 id="min-required-rustc-version" class="section-header"><a href="#min-required-rustc-version">Min required rustc version</a></h4>
<p>By default the minimum required rustc version is 1.51.</p>
<p>There is an optional feature you can enable called “old_rust” that enables
support down to rustc version 1.36. However this requires polyfilling std
library functionality for older rustc with technically UB versions. Testing
does not show older rustc versions (ab)using this. Use at your own risk.</p>
<p>The minimum versions are a best effor and may change with any new major
release.</p>
</div></details><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.self_cell.html" title="self_cell::self_cell macro">self_cell</a></div><div class="item-right docblock-short"><p>This macro declares a new struct of <code>$StructName</code> and implements traits
based on <code>$AutomaticDerive</code>.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="self_cell" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>